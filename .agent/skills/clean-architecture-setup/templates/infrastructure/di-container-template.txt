Dependency Injection Container Configuration

Context: {{CONTEXT}}

Bindings:
- Repositories: Domain interfaces → Infrastructure implementations
- Ports: Application interfaces → Infrastructure adapters
- Handlers: Application handlers as singletons

---

<?php

namespace App\Infrastructure\Config;

use Illuminate\Support\ServiceProvider;

// Domain Repositories
use App\Domain\{{CONTEXT}}\Repositories\{
    {{REPOSITORY_1}},
    {{REPOSITORY_2}}
};

// Infrastructure Implementations
use App\Infrastructure\Persistence\{
    {{REPOSITORY_1_IMPL}},
    {{REPOSITORY_2_IMPL}}
};

// Application Ports
use App\Application\Ports\{
    EmailService,
    EventBus,
    PaymentGateway
};

// Infrastructure Adapters
use App\Infrastructure\External\{
    LaravelEmailService,
    LaravelEventBus,
    StripePaymentGateway
};

// Application Handlers
use App\Application\{{CONTEXT}}\Handlers\{
    {{HANDLER_1}},
    {{HANDLER_2}}
};

class DependencyInjectionContainer extends ServiceProvider
{
    /**
     * Register application services
     */
    public function register(): void
    {
        $this->registerRepositories();
        $this->registerPorts();
        $this->registerHandlers();
    }
    
    /**
     * Bind repository interfaces to implementations
     */
    private function registerRepositories(): void
    {
        $this->app->bind({{REPOSITORY_1}}::class, {{REPOSITORY_1_IMPL}}::class);
        $this->app->bind({{REPOSITORY_2}}::class, {{REPOSITORY_2_IMPL}}::class);
    }
    
    /**
     * Bind application ports to infrastructure adapters
     */
    private function registerPorts(): void
    {
        $this->app->bind(EmailService::class, LaravelEmailService::class);
        $this->app->bind(EventBus::class, LaravelEventBus::class);
        
        // Bind with configuration
        $this->app->bind(PaymentGateway::class, function ($app) {
            return new StripePaymentGateway(
                config('services.stripe.secret')
            );
        });
    }
    
    /**
     * Register handlers as singletons
     */
    private function registerHandlers(): void
    {
        $this->app->singleton({{HANDLER_1}}::class);
        $this->app->singleton({{HANDLER_2}}::class);
    }
    
    /**
     * Bootstrap application services
     */
    public function boot(): void
    {
        // Register routes, migrations, etc.
    }
}

// ============================================
// Alternative: Node.js/TypeScript (InversifyJS)
// ============================================

/*
import { Container } from 'inversify';
import { TYPES } from './types';

// Domain
import { {{REPOSITORY_1}} } from '@domain/{{context}}/repositories/{{REPOSITORY_1}}';

// Infrastructure
import { {{REPOSITORY_1_IMPL}} } from '@infrastructure/persistence/{{REPOSITORY_1_IMPL}}';

// Application
import { {{HANDLER_1}} } from '@application/{{context}}/handlers/{{HANDLER_1}}';

const container = new Container();

// Bind repositories
container.bind<{{REPOSITORY_1}}>(TYPES.{{REPOSITORY_1}})
    .to({{REPOSITORY_1_IMPL}})
    .inSingletonScope();

// Bind handlers
container.bind<{{HANDLER_1}}>(TYPES.{{HANDLER_1}})
    .to({{HANDLER_1}})
    .inSingletonScope();

export { container };
*/

// ============================================
// Alternative: Spring Boot (Java)
// ============================================

/*
@Configuration
public class DependencyInjectionConfig {
    
    @Bean
    public {{REPOSITORY_1}} {{repository1}}(DataSource dataSource) {
        return new {{REPOSITORY_1_IMPL}}(dataSource);
    }
    
    @Bean
    public {{HANDLER_1}} {{handler1}}(
        {{REPOSITORY_1}} {{repository1}},
        EmailService emailService
    ) {
        return new {{HANDLER_1}}({{repository1}}, emailService);
    }
}
*/
